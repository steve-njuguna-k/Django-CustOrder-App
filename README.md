# Django Custumser Order App
A Django Customer Order App, built on PostgreSQL database &amp; with API endpoints using DjangoRestFramework. Authentication &amp; Authorization is through OpenID Connect. CICD pipeline is done through CircleCI and deployment is on AWS through CloudFormation.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/AWS-API-ENDPOINT.png)

# App Database
The customer model. It consists of a unique UUID, First Name, Last Name, Phone Number, Date Created & Date Modified
```
class Customer(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    first_name = models.CharField(max_length=250, verbose_name='First Name', null=False, blank=False)
    last_name = models.CharField(max_length=250, verbose_name='Last Name', null=False, blank=False)
    phone_number = models.CharField(max_length=250, verbose_name='Phone Number', null=False, blank=False)
    date_created = models.DateTimeField(verbose_name='Date Created',auto_now_add=True)
    date_modified = models.DateTimeField(verbose_name='Date Modified',auto_now=True)
```

The Item model. It consists of a unique UUID, Item Name, Item Size, Item Price, Date Created & Date Modified
```
class Item(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    name = models.CharField(max_length=250, verbose_name='Name', null=False, blank=False)
    size = models.TextField(verbose_name='Size', choices=SIZES, null=False, blank=False)
    price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='Price', null=False, blank=False)
    date_created = models.DateTimeField(verbose_name='Date Created',auto_now_add=True)
    date_modified = models.DateTimeField(verbose_name='Date Modified',auto_now=True)
```

The Order model.. It consists of a unique UUID, Customer (FK), Item (FK), Quantity, Date Created & Date Modified. The total is calculated using the quantity & price
```
class Order(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    customer = models.ForeignKey('Customers.Customer', on_delete=models.PROTECT, verbose_name='Customer', null=False, blank=False)
    item = models.ForeignKey('Items.Item', on_delete=models.PROTECT, verbose_name='Item', null=False, blank=False)
    quantity = models.PositiveIntegerField(verbose_name='Quantity', null=False, blank=False)
    date_created = models.DateTimeField(verbose_name='Date Created',auto_now_add=True)
    date_modified = models.DateTimeField(verbose_name='Date Modified',auto_now=True)

    def _get_order_item_total(self):
        return self.item.price * self.quantity
    
    total = property(_get_order_item_total)
```

# API Endpoints
The API endpoints provide CRUD functionalities for authenticated & authorized users.
```
{
  "Title": "Customer Endpoints",
  "Create A Customer": "[POST] /v1/customers",
  "List Customers": "[GET] /v1/customers",
  "Get Customer Details": "[GET] /v1/customers/:id",
  "Update Customer Details": "[PATCH] /v1/customers/:id",
  "Delete Customer Details": "[DELETE] /v1/customers/:id",
}, {
  "Title": "Item Endpoints",
  "Create An Item": "[POST] /v1/items",
  "List Items": "[GET] /v1/items",
  "Get Item Details": "[GET] /v1/items/:id",
  "Update Item Details": "[PATCH] /v1/items/:id",
  "Delete Item Details": "[DELETE] /v1/items/:id",
}, {
  "Title": "Order Endpoints",
  "Create An Order": "[POST] /v1/orders",
  "List Orders": "[GET] /v1/orders",
  "Get Order Details": "[GET] /v1/orders/:id",
  "Update Order Details": "[PATCH] /v1/orders/:id",
  "Delete Order Details": "[DELETE] /v1/orders/:id",
}
```

# OpenID Connect Authentication & Authorization
OpenID Connect (OIDC) is an authentication layer built on top of OAuth 2.0, and it's designed to provide user authentication and identity information to client applications. OIDC extends OAuth 2.0 by adding a standardized way for applications to verify the identity of users and obtain information about them. 

In this project, I used the Django Admin login for authorization. The Django server acts as both the Authorization Server & Resource Server. To create a superuser:
```
python manage.py createsuperuser

Username:
Email address:
Password:
Password (again):
Superuser created successfully.
```

Start the development server
```
python manage.py runserver
```

To create an client application, you need to login first. Then head over to <YOUR_IP_ADDRESS>/o/applications/register/ to create an application. During registration, the client application receives a Client ID, which is a public identifier for the application and also a Client Secret. Copy the autogenerated Client ID & Client Secret for later use.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/APPLICATION-CREATION.png)

After creating an app, you will be redirected to show all you app details. The Client Secret will be hashed after creating the application.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/APPLICATION-DETAILS.png)

Proof Key for Code Exchange (PKCE) is an important security feature in OAuth 2.0 and the OIDC Authorization Code Flow. Its primary purpose is to enhance the security of the authorization code flow, especially in situations where client secrets cannot be securely stored, such as in single-page applications (SPAs) or mobile apps. To generate an authentication code grant with PKCE, you must first generate a Code Verifier random string between 43 and 128 characters, which is then encoded to produce a Code Challenge.
```
import random
import string
import base64
import hashlib

code_verifier = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randint(43, 128)))
code_verifier = base64.urlsafe_b64encode(code_verifier.encode('utf-8'))

code_challenge = hashlib.sha256(code_verifier).digest()
code_challenge = base64.urlsafe_b64encode(code_challenge).decode('utf-8').replace('=', '')
```
PKCE is important because it addresses security concerns in OAuth 2.0 and OIDC by providing an additional layer of protection against code interception attacks and unauthorized access to user data. It is particularly valuable for applications that cannot securely store client secrets and aligns with modern application security best practices. PKCE enhances the overall security and trustworthiness of the authentication process in the context of OAuth 2.0 and OIDC. Copy the autogenerated Code Verifier & Code Challenge for later use.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/CODE-VERIFIER-&-CODE-CHALLENGE-GENERATION.png)

To start the Authorization code flow, constructs an authorization request URL as below:
```
<YOUR_IP_ADDRESS>/o/authorize/?response_type=code&code_challenge=CODE_CHALLENGE&code_challenge_method=S256&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=openid
```

Note the parameters we pass:
```
•	response_type: code #indicates that the authorization code will be returned.
•	scope: openid #The requested permissions or scopes.
•	code_challenge: CODE-CHALLENGE #A dynamically generated value (PKCE challenge) derived from a secret Code Verifier. This is a crucial component of PKCE for enhanced security.
•	code_challenge_method: S256 #The method of hashing used to encode the Code Verifier
•	client_id: CLIENT_ID #The Client ID obtained during registration.
•	redirect_uri: <YOUR_IP_ADDRESS>/o/callback #A callback URL where the authorization code will be sent after successful authentication.
```

The authorization request is sent to the Authorization Server, which then authenticates the user.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/AUTHORIZATION-CONSENT-SCREEN.png)

If the user's authentication is successful, the Authorization Server generates an authorization code and sends it back to the client application at the provided redirect_uri.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/AUTHORIZATIO-CODE-GENERATION.png)

Upon receiving the authorization code, using CURL, head over to PostMan and initiate a POST request to the token URL to exchange the authorization code for an Access Token. The Authorization Code has a lifespan of 5 minutes before expirying.
```
curl -X POST \
    -H "Cache-Control: no-cache" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    <YOUR_IP_ADDRESS>/o/token/" \
    -d "client_id=${ID}" \
    -d "client_secret=${SECRET}" \
    -d "code=${CODE}" \
    -d "code_verifier=${CODE_VERIFIER}" \
    -d "redirect_uri=<YOUR_IP_ADDRESS>/o/callback" \
    -d "grant_type=authorization_code"
```

Note the parameters we pass:
```
•	grant_type: Set to "authorization_code" indicating the code exchange flow.
•	client_id: The Client ID.
•	client_secret: The Client Secret.
•	code: The received authorization code.
•	redirect_uri: The same callback URL used in the authorization request.
•	code_verifier: The original secret code verifier used to generate the code_challenge. This is required for PKCE.
```

The Authorization Server validates the authorization code, client ID, client secret, the PKCE code verifier is validated against the hashed code challenge using the code challenge challenge method. If all are valid, the Authorization Server responds with an Access Token, Refresh Token and an ID token.

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/ACCESS-TOKEN-GENERATION.png)

You can now use the Access Token to gain access to protected API endpoints such as:

Create a Customer

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/CUSTOMER-CREATION.png)

Create a Item

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/ITEM-CREATION.png)

Create an Order

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/ORDER-CREATION.png)

Upon creating an Order, using the AfricasTalking Simulator, you will receive an SMS for order confirmation

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/SMS-SIMULATOR-RESULT.png)

# CircleCI Pipeline
The CI/CD pipeline is made up 4 main stages

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/PIPELINE.png)

### Build Test Stage
This stage is where the application packages are installed and all testcases are ensured to be compliant

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/BUILD-TEST.png)

The test cases results

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/TEST-RESULTS.png)

### Test Coverage
This is where the test coverage report is created to show what percentage of the entire code is properly tested

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/TEST-COVERAGE.png)

The test coverage results

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/COVERAGE-REPORT.png)

### Push To DockerHub
This is where a Docker image is built then push to DockerHub

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/PUSH-TO-DOCKERHUB.png)

The DockerHub Image

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/DOCKER-HUB-REPO.png)

### Deploy EC2 Instance
This is where an AWS EC2 instance is deployed using CloudFormation

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/DEPLOY-EC2-INSTANCE.png)

The CloudFormation Deployment Result

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/CLOUDFORMATION-DEPLOYMENT.png)

The EC2 Server

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/EC2-SERVER.png)

Accessing The Application API Endpoint at <AWS_EC2_INSTANCE_PUBLIC_IP>/api

![](https://github.com/steve-njuguna-k/Django-CustOrder-App/blob/master/Screenshots/AWS-API-ENDPOINT.png)

© 2023 Steve Njuguna
