# CircleCI configuration version
version: 2.1

# Define custom commands that can be used in jobs
commands:

  # Install AWS CLI v2
  install_awscli:
    description: Install AWS CLI v2
    steps:
      - run:
          name: Install AWS CLI v2
          command: |
            # Download and install AWS CLI v2
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install

  # Destroy cloudformation stacks given a workflow ID
  destroy-environment:
    description: Destroy cloudformation stacks given a workflow ID.
    parameters:
      Workflow_ID:
        type: string
        default: ${CIRCLE_WORKFLOW_ID:0:7}
    steps:
      - run:
          name: Destroy environments
          when: on_fail  # Run only on job failure
          command: |
            # Delete a CloudFormation stack using the specified Workflow ID
            aws cloudformation delete-stack --stack-name $STACK_NAME-<< parameters.Workflow_ID >>

# Define individual jobs that can be executed in the workflow
jobs:

  # Build and test job
  build-test:
    # Primary container image where all commands run
    docker:
      - image: cimg/python:3.10
        environment:
          TEST_DATABASE_URL: postgresql://postgres@localhost/circle_test

    # Service container image
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: postgres

    steps:
      - checkout  # Checkout your code repository

      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "requirements.txt" }}

      - run:
          name: Install dependencies
          command: pip install -r requirements.txt  # Install project dependencies

      - save_cache:
          key: v1-dependencies-{{ checksum "requirements.txt" }}
          paths:
            - ~/.cache/pip  # Cache the Python packages for future builds

      - run:
          name: Run tests
          command: |
            python manage.py test

  # Test coverage job
  test-coverage:
    # Primary container image where all commands run
    docker:
      - image: cimg/python:3.10
        environment:
          TEST_DATABASE_URL: postgresql://postgres@localhost/circle_test

    # Service container image
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: postgres

    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "requirements.txt" }}

      - run:
          name: Install dependencies
          command: pip install -r requirements.txt  # Install dependencies for coverage

      - run:
          name: Run coverage
          command: |
            coverage run manage.py test
            coverage xml

      - save_cache:
          key: v1-coverage-{{ checksum "requirements.txt" }}
          paths:
            - .coverage  # Cache coverage data for future reference

  # Push to Docker Hub job
  push-to-dockerhub:
    # Primary container image where all commands run
    docker:
      - image: cimg/python:3.10
        environment:
          TEST_DATABASE_URL: postgresql://postgres@localhost/circle_test

    # Service container image
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: postgres

    steps:
      - checkout # Step to check out the source code
      - setup_remote_docker
      - run:
          name: Build Docker image
          command: docker build -t $IMAGE_NAME .
          # Build a Docker image using the specified IMAGE_NAME

      - run:
          name: Push to DockerHub
          command: |
            echo "$DOCKERHUB_PASS" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

            # Tag and push the built image to Docker Hub with the 'latest' tag
            docker tag $IMAGE_NAME:latest $DOCKERHUB_USERNAME/$IMAGE_NAME
            docker push $DOCKERHUB_USERNAME/$IMAGE_NAME:latest

  # Deploy EC2 instance job
  deploy-ec2-instance:
    docker:
      - image: cimg/base:stable

    steps:
      - checkout  # Checkout your code
      - install_awscli

      - run:
          name: Deploy CloudFormation Stack
          command: |
            # Configure AWS CLI with your AWS credentials
            aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
            aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
            aws configure set default.region $AWS_DEFAULT_REGION

            # Deploy the CloudFormation stack
            aws cloudformation deploy \
              --template-file .circleci/files/cloudformation_template.yml \
              --tags project=$STACK_NAME \
              --stack-name "$STACK_NAME-${CIRCLE_WORKFLOW_ID:0:7}" \
              --parameter-overrides ID="${CIRCLE_WORKFLOW_ID:0:7}"

      - run:
          name: Get EC2 instance information
          command: |
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=CustOrder-Server" --query "Reservations[0].Instances[0].InstanceId" --output text)
            PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
            USERNAME=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].KeyName" --output text)
            echo "Instance ID: $INSTANCE_ID"
            echo "Public IP: $PUBLIC_IP"
            echo "Username: $USERNAME"
      
      - destroy-environment  # Run the destroy-environment command to delete resources
  
  run-docker-image-on-ec2:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout  # Checkout your code
      - install_awscli
      - run:
          name: Deploy
          command: |
            # 1- Get the public IP of the current CircleCI runner
            PUBLIC_IP=$(curl ipinfo.io/ip)
            echo "PUBLIC_IP: $PUBLIC_IP"

            # 2- Get AWS Region# TODO Don't forget to replcae by your own Region
            AWS_REGION=$AWS_DEFAULT_REGION

            # 3- Get SG ID# TODO Don't forget to replace by your own SG ID
            SG_ID=$SG_ID

            # 4- SSH to the server to deploy
            echo "Setting up SSH..."
            mkdir -p ~/.ssh
            echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan -H $EC2_PUBLIC_IP >> ~/.ssh/known_hosts
            ssh -i ~/.ssh/id_rsa $EC2_USERNAME@$EC2_PUBLIC_IP << EOF
              echo "Setting up environment variables..."
              export SECRET_KEY=$SECRET_KEY
              export DEBUG=$DEBUG
              export ALLOWED_HOSTS=$ALLOWED_HOSTS
              export AT_API_KEY=$AT_API_KEY
              export AT_USERNAME=$AT_USERNAME
              export DB_ENGINE=$DB_ENGINE
              export DB_NAME=$DB_NAME
              export DB_USER=$DB_USER
              export DB_PASSWORD=$DB_PASSWORD
              export DB_HOST=$DB_HOST
              export DB_PORT=$DB_PORT
              export DJANGO_SUPERUSER_USERNAME=$DJANGO_SUPERUSER_USERNAME
              export DJANGO_SUPERUSER_EMAIL=$DJANGO_SUPERUSER_EMAIL
              export DJANGO_SUPERUSER_PASSWORD=$DJANGO_SUPERUSER_PASSWORD
              export DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME
              export DOCKERHUB_PASS=$DOCKERHUB_PASS

              echo "Starting Docker Compose..."
              cd App/Django-CustOrder-App-master
              sudo docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASS
              sudo docker-compose -f docker-compose-prod.yml up -d --build
            EOF

# Define the workflow for the CI/CD pipeline
workflows:
  version: 2

  build-test:
    jobs:
      - build-test  # Run the 'build-test' job for building and testing
      - test-coverage:
          requires:
            - build-test  # Require the 'build-test' job to complete before running coverage
      - push-to-dockerhub:
          requires:
            - test-coverage  # Require the 'test-coverage' job to complete before pushing to Docker Hub
      - deploy-ec2-instance:
          requires:
            - push-to-dockerhub  # Require the 'push-to-dockerhub' job to complete before deploying the EC2 instance
      - run-docker-image-on-ec2:
          requires:
            - deploy-ec2-instance  # Require the 'deploy-ec2-instance' job to complete before deploying the EC2 instance
